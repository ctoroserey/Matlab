function [out] = customLogistic(subjectMatrix)
%% Function specific to data generated by the foraging task. Subject matrices generated
% by logread.m are ideal for this. It generates a struct containing: 
%
%   - Summary table with coefficients, pvals, and model deviance for each level of nested model (including interaction effects)
%
%   - Null deviance for the model without predictors
%
% Claudio 6/14/17

%% data setup
indx = subjectMatrix(:,3)~=2; % filter out the 2s from the cognitive group decision column
subj = subjectMatrix(indx,:);
notNan = ~isnan(subj(:,1)); % no need because mnrfit doesn't consider NaN
subj = subj(notNan,:);
y = subj(:,3);
x1 = subj(:,1); % handling
x2 = subj(:,2); % rewards
all = [y x1 x2];
all = sortrows(all,[2 3]);
x = [all(:,2) all(:,3)];
y = all(:,1);
% "mean centering" so that the intercept = 5 pts and/or 2s
x(:,1) = x(:,1) - 2;
x(:,2) = x(:,2) - 5;
% add an interaction term 
xInt = [x x1.*x2]; 

%% logistic model
[~,nullDev] = mnrfit([],2-y);
% continuous predictors
[~,devH,statsH] = mnrfit(x(:,1),2-y);
[~,devR,statsR] = mnrfit(x(:,2),2-y);
[~,dev,stats] = mnrfit(x,2-y);
[~,devInt,statsInt] = mnrfit(xInt,2-y);

% linear function for 2 features + intercept. Here in case you want to calculate probabilities
% mnrval(stats.beta,[x1val x2val]) also works (first number is the probability of accepting)
g = @(h,r) stats.beta(1) + stats.beta(2).*h + stats.beta(3).*r; 
g2 = @(h1,h2,r1,r2) stats.beta(1) + statsNom.beta(2).*h1 + statsNom.beta(3).*h2 + statsNom.beta(4).*r1 + statsNom.beta(5).*r2; 
g3 = @(h,r,i) statsInt.beta(1) + statsInt.beta(2).*h + statsInt.beta(3).*r + statsInt.beta(4).*i;

% probability of accepting a trial based on continuous (does pretty well)
% probH = 1./(1 + exp(-(statsH.beta(1) + statsH.beta(2).*14)));
% probR = 1./(1 + exp(-(statsR.beta(1) + statsR.beta(2).*25)));
% probBoth = 1./(1 + exp(-(g(14,25)))); % probability for the combo 
% probInt = 1./(1 + exp(-(g3(1,1,1)))); % probability for the interaction

% tables (those who always accepted get a deviance of 0 (messing up the
% table due to lack of betas), so I patched with NaNs for now instead)
if nullDev == 0 && devH == 0
    con = {'Handling','Reward','bothH','bothR','InteractionH','InteractionR','Interaction'}'; % labels for continuous
    summaryCon = table(con,[NaN,NaN,NaN,NaN,NaN,NaN,NaN]',...
        [NaN,NaN,NaN,NaN,NaN,NaN,NaN]',...
        [NaN,NaN,NaN,NaN,NaN,NaN,NaN]',...
        'VariableNames',{'Condition','Betas','Pvals','Model_deviance'});    
else
    con = {'Handling','Reward','bothH','bothR','InteractionH','InteractionR','Interaction'}'; % labels for continuous
    summaryCon = table(con,[statsH.beta(2),statsR.beta(2),stats.beta(2),stats.beta(3),statsInt.beta(2),statsInt.beta(3),statsInt.beta(4)]',...
        [statsH.p(2),statsR.p(2),stats.p(2),stats.p(3),statsInt.p(2),statsInt.p(3),statsInt.p(4)]',...
        [devH,devR,dev,0,devInt,0,0]',...
        'VariableNames',{'Condition','Betas','Pvals','Model_deviance'});
end
%% testing side, incorporating discrete predictors (no need, but kept just in case)
% n = [1:1:length(y)]';
% [~, devGlm, statsGlm] = glmfit([catx (catx(:,1).*catx(:,3)) (catx(:,1).*catx(:,4)) ...
%      (catx(:,2).*catx(:,3)) (catx(:,2).*catx(:,4))], [y n], 'binomial', 'link', 'probit');

% % interaction (NOT CONVERGING)
% designMatrix = [catx (catx(:,1).*catx(:,3)) (catx(:,1).*catx(:,4)) ...
%     (catx(:,2).*catx(:,3)) (catx(:,2).*catx(:,4))];
% [~,devInt,statsInt] = mnrfit(designMatrix,2-y);
% 1./(1 + exp(-(statsNom.beta(1) + statsNom.beta(2).*1 + statsNom.beta(3).*0)))

out.Summary = summaryCon;
out.nullDev = nullDev;

clear subj notNan x1 x2 x y catx1 catx2 xInt g g2 g3 con nom index

end