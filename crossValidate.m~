function [out, summary] = crossValidate(Matrix)

[~,~,nSubs] = size(Matrix);

MatrixB = [];
MatrixA = [];

for i = 1:nSubs
    
    % find the break
    index = find(Matrix(:,1,i)==99);
    
    % get the before-break data
    tempMatrix = Matrix(1:(index-1),:,i);
    [rows,columns] = size(tempMatrix);
    MatrixB(1:rows,1:columns,i) = tempMatrix;
    
    % get the post-break data
    tempMatrix = Matrix((index+1):end,:,i);
    [rows,columns] = size(tempMatrix);
    MatrixA(1:rows,1:columns,i) = tempMatrix;
    
end

for i = 1:nSubs
    
    col = MatrixB(:,1,i); % grab the delay column for subject j

    if col(end) == 0
        extras = find(col==0); % get indexes for extras
        MatrixB(extras,:,i) = NaN; % convert to NaN
    end
end      

% set up the matrix for optimization
MatrixB = setAll(MatrixB);

%% model OR overall (updated with physical)

ModelOR = [];
ModelPredicted = [];

% structs containing each subject's model results
SubjectOR = struct('percentNow',{},'percentDelayed',{},'percentMissed',{},...
    'beta',{},'scale',{},'LL',{},...
    'LL0',{},'r2',{},'SOC',{},'prob',...
    {},'predictedChoice',{},'percentPredicted',{});


% estimate the OC per subject
for i = 1:nSubs
    
    SubjectOR(i) = foragingOCModel(MatrixB(:,3,i),MatrixB(:,6,i),MatrixB(:,2,i),MatrixB(:,1,i),0);
    ModelOR(i) = SubjectOR(i).beta;
    ModelPredicted(i) = SubjectOR(i).percentPredicted;

end   

clear i 

% eliminate NaN instances
ModelOR(isnan(ModelOR)) = [];
ModelPredicted(ModelPredicted==0) = [];

% Plot the OCs (requires the function dotDist)
%OCfig = dotDist([ModelOR.WaitAll(:,1), ModelOR.CognitiveAll(:,1), ModelOR.PhysicalAll(:,1)],{'Wait','Cognitive','Physical'});

%% Cross validate?

ModelPredicted = [];

for i = 1:nSubs
    
    Choice = MatrixA(:,3,i);
    miss = Choice ~= 0 & Choice ~= 1;
    choice = Choice(~miss); % choice data for valid trials
    Reward = MatrixA(:,2,i);
    Rwd = Reward(~miss); % reward for valid trials
    Handling = MatrixA(:,1,i);
    Handle = Handling(~miss); % handle time for valid trials

    out(i).scale = SubjectOR(i).scale;
    out(i).SOC = SubjectOR(i).beta.*Handle; % subjective opportunity cost (weighted)
    out(i).prob = 1 ./ (1 + exp(-(out(i).scale.*(Rwd - out(i).SOC))));
    out(i).predictedChoice = Rwd > out(i).SOC; % 1 if delayed option is greater
    out(i).percentPredicted = sum(out(i).predictedChoice == choice) / length(choice) * 100;
    out(i).negLL = -sum((choice==1).*log(p) + (choice==0).*log(1-p));
    ModelPredicted(i) = out(i).percentPredicted;
    
end


summary = [ModelOR; ModelPredicted]';

end

function negLL = negLL(beta,choice,Handle,Rwd)
p = probcalc(beta,Handle,Rwd);
negLL = -sum((choice==1).*log(p) + (choice==0).*log(1-p));
end

function p = probcalc(beta,Handle,Rwd)  
sOC = (exp(beta(2)).*Handle); % opportunity cost
reg = exp(beta(1)).*(Rwd - sOC); % get the logodds with weighted noise
p = 1 ./ (1 + exp(-reg)); % sigmoidal function
p(p == 1) = 1-eps;
p(p == 0) = eps;
end